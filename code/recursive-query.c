/*
WITH RECURSIVE search_graph(id, link, data, depth) AS (
        SELECT g.id, g.link, g.data, 1
        FROM graph g WHERE g.link IS NULL
      UNION ALL
        SELECT g.id, g.link, g.data, sg.depth + 1
        FROM graph g, search_graph sg
        WHERE g.id = sg.link
)
SELECT * FROM search_graph;
*/

// it seems like the outer where clause and possibly the data of the join/tables
// are the primary set of constraints on the states the imperative loops can
// exist under.

// what is the relationship between the halting problem and the algo
// described in the paper Proving Non-Termination. It appears to be state space
// exploration is infinite which we might be able to confine
//
// does the problem reduce to finding cycles in the data always?
//
// if there's some way to detect the graph generated by the recursive algo
// then whether it will terminate is decideable for a given table state
//
// reverse question about liveness
//
// it seems like you'd never want cycles in the data because of the union. That is
// it's never going to provide new information (tuples) other than that which might
// be generated by the recursive nature of the query.
//
// detect graph generation portion of query + generate graph from data + break on
// cycle

struct graph set[n];
struct graph all[n];

// "base case"  query
// it seems like the constraints are going to be based entirely on the
// the state of what's generated here (obvious from tables)
struct graph newset[n] = graph_root();

while( newset.length != 0 ) {
  // union with subsequent recursive
  set = union(set, newset);

  all = graph_all();

  // from the set of all elements in the graph find the
  // ones that have a link matching the latest newset ids
  while( i < all.length ) {
    while( j < newset.length ) {
      if( all[i].link == newset[j].id /* && other constraints */ ){
        update.push( all[i] )
      }
    }
  }

  // the links form the new newset.
  newset = update;
}
